# 浏览器渲染原理

渲染引擎
  火狐: Gecko,
  谷歌、safari: webkit

1. 浏览器接收到html文件并转换为 DOM 树
当数据转化为字符串以后浏览器会先将这些字符串通过词法分析和转换为 标记，这个过程我们叫为标记化

字节数据 ==》 字符串 ==》 Token (标记，构成代码的最小单位)

当标记化结束后，这些标记会接着转换为Node，最后这些Node会根据不同 Node之前的联系建成一颗 DOM 树


2. 将 css 文件转换为 cssom 树
这个过程中，浏览器会确定每一个节点的样式到底是什么，这个过程是很消耗资源的，因为样式可以自行设置，也可以继承得来，所以这个过程中得递归 cssom 树，然后确定具体的元素到底是什么样式


3. 生成渲染树
DOM树 + CSSOM树，但不是简单的合并，渲染树只会包含需要显示的节点和这些节点的样式信息，如果节点是 dispaly: none; 的，就不会再渲染树中显示。


4. 渲染
根据渲染树来布局 （回流），调用GPU绘制，合成图层显示在屏幕上


# 为什么操作 DOM 慢？
1. js直接操作dom这其中涉及到两块内容，js是靠js引擎来执行的，而操作的dom是靠渲染引擎来执行的，所以这个操作势必会带来两个线程之间的通信，也就一定会开销额外的性能。操作的dom次数一多也就等同于 一直在进行线程的通信。
2. 操作dom会造成重绘回流的情况，也就导致性能开销。


# 插入几万个dom，如何实现页面不卡顿？
解决这个问题的重点应该是想如何分批次的渲染部分DOM
1. requestAnimationFrame的方式去循环的插入dom
2. 另一种实现方式: 虚拟滚动: 只渲染可视区域，非可视区域完全不渲染，当用户滚动的时候去替换渲染的内容
<!-- https://bvaughn.github.io/react-virtualized/#/components/List -->


# 什么情况会阻塞渲染？
1. html和css会阻塞渲染，所以我们应该降低一开始需要渲染的文件的大小，并且扁平层级，优化选择器。

2. script 标签的解析会导致暂停DOM的构建，解析完之后才会继续构建DOM，所以要想首屏渲染的越快，越不能在首屏加载js，这也是为什么script标签要尽量放在body底部的原因，（当script加上defer这个属性时，就会默认把js放在html解析完成之后所以script放在哪都可以）

3. 对于没有任何依赖的js文件，可以加上async属性，表示js文件下载和解析是异步的不会阻塞渲染。



# 重绘 (repaint) 和 回流  (reflow)
  - 重绘:
      需要改变外观而不影响布局，比如改变color就叫重绘
  - 回流
      布局几何属性需要改变

回流必定会重绘，重绘不一定会引发回流

以下几个动作会导致性能问题:
  1. 改变window大小
  2. 改变字体
  3. 添加或删除样式
  4. 文字大小


  你不知道的是: 回流和重绘其实跟 EventLoop 有关
  1. Eventloop执行完微任务后，会判断 document 是否需要更新，因为浏览器是60HZ的刷新率，每16.6ms会更新一次
  2. 然后判断是否有resize或者scroll事件，有的话就会触发事件，所以resize和scroll也是至少16ms才会触发一次
  3. 判断是否触发了 media query
  4. 更新动画发送事件
  5. 判断是否全屏
  6. 执行requestAnimationFrame回调
  7. 执行 IntersectionObserver回调，该方法用来判断元素是否可见
  8. 更新页面

  以上就是一帧可能会干的事

  # 减少重绘和回流
  1. demo1.html
  2. 尽量不要用table布局，因为table中很小的改动就会造成整个table的重新布局


